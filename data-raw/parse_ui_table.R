library(gsubfn)

#' Development tool, used to generate a simple UI from the configuration table
#' of model inputs `dev/input_config.tsv`
#'
#' @details
#' Customize the header and closing directly on this function.
#' The format and parsing of groups of inputs is controlled by sub-function `write_chunk`.
#'
#' Features like limits, slider steps, and visibility are set dynamically by `load_input_config`,
#' and are set by `get_PSA_input_limits`.
#'
#' @export `R/auto_generated_ui.R` function code returning a `tabsetPanel`
#'  object, to be used in `app_ui.R`, using `auto_generated_ui(id, ...)`
#'
#' @export `data/input_config_table.rda` parsed table, which is
#'  used by functions in `R/utils.R` to identify model input types and
#'  configurations.
#'
#' @importFrom glue::glue
#' @import gsubfn
#' @noRd
parse_ui_table <- function() {

  # Expected column names
  COL_NAMES <- c("group", "id", "type", "basic", "fixed", "default", "rel_min", "rel_max", "abs_min", "abs_max", "step", "unit", "description", "notes")

  # Read input config table from INPUT_FILE, make sure all columns are available
  input_config_table <- read.delim(INPUT_FILE, na.strings = c("NA", "?", ""), blank.lines.skip = T)

  input_config_table$default <- I(as.list(input_config_table$default))

  stopifnot(rlang::is_empty(setdiff(COL_NAMES, colnames(input_config_table))))

  # Remove empty lines
  empty_lines <- apply(input_config_table, 1, is.empty)
  input_config_table <- input_config_table[!empty_lines, ]

  # Make sure each input is assigned to a group, and they are sorted
  input_config_table <- assign_groups(input_config_table)

  # config_table$basic

  # Keep a list of all inputs...
  # add_to_list(config_table$id,"all_inputs")

  input_config_table$valid <- !sapply(input_config_table$id, is.empty)
  input_config_table$basic <- grepl("[xty1]+", input_config_table$basic, ignore.case = T)
  input_config_table$fixed <- grepl("[xty1]+", input_config_table$fixed, ignore.case = T)

  # main --------------------------------------------------------------------

  write_out("# Code generated by parse_ui_table.R, ", date(), "\n", append = F)
  write_out("# Edit input config in: data_raw/input_config.tsv:\n")
  write_out("# Edit parsing rules & layout in: data_raw/parse_ui_table.R\n")

  write_out("auto_generated_ui <- function(...) {{\n\n")
  write_out('  tabsetPanel( ... ,\n')

  for (grp in levels(input_config_table$group)) {
    in_grp <- input_config_table$group == grp
    chunk <- input_config_table[in_grp, ]

    chunk <- parse_chunk(chunk)

    input_config_table[in_grp, ] <- chunk
  }

  write_out('  )\n')
  write_out('}}\n')

  ok <- input_config_table$valid
  dup <- ok
  dup[ok] <- duplicated(input_config_table$id[ok])
  ok <- ok & !dup

  rownames(input_config_table)[ok] <- input_config_table$id[ok]

  if (any(dup)) {
    msg <- input_config_table[dup, c("group", "id", "type", "description")]
    msg <- paste(capture.output(print(msg)), collapse = "\n")
    stop("Non-unique input IDs!\n", msg)
  }

  # add_use_data("input_config_table" = input_config_table)
  usethis::use_data(input_config_table, internal = F, overwrite = T)
}

is.empty <- function(x) {
  (all(rlang::is_empty(x) | is.na(x) | x == ""))
}

write_out <- function(..., file = OUTPUT_UI, append = T) {
  cat(glue(..., .trim = F, .envir = parent.frame(n = 1)), file = file, append = append)
}

is.numeric.ish <- function(x) !is.empty(x) && !suppressWarnings(is.na(as.numeric(x)))

is_group_header <- function(line) !is.empty(line$group) && is.empty(line$id)

#' Process a group of inputs
#'
#' @param chunk a block of lines from `input_config_table` representing group of UI inputs.
#' @return parsed chunk
#'
parse_chunk <- function(chunk) {
  stopifnot(length(unique(chunk$group)) == 1)
  group <- as.character(chunk$group[1])
  title <- as.character(chunk$description[1])

  elements <- NULL
  for (j in seq_len(nrow(chunk))) {
    line <- as.list(chunk[j, ])
    list[x, line] <- parse_line(line)

    elements <- c(elements, x)
    chunk[j, ] <- line
  }

  write_chunk(group, title, elements)
  return(chunk)
}

#' Writes a `tabPanel`  for a given UI `group`
#'
#'  tabPanel(title = "group",
#'    h3("title"),
#'    numericInput("foo", "Foo?", value = 42),
#'    sliderInput("bar", "Bar?", value = 0.5, min = 0, max = 1)
#'  ),
#'
write_chunk <- function(group, title = NULL, elements, .INDENT = 4) {

  tabs <- stringr::str_flatten(rep(" ",.INDENT))

  indented <- function(lines, n = .INDENT + 2) {
    tabs <- stringr::str_flatten(rep(" ",n))
    paste0(tabs,gsub("(\\n)",paste0("\\1",tabs),lines))
  }


  write_out(tabs,'tabPanel(title = "{group}",\n')
  write_out(tabs,'  h3("{title}"),\n')

  if (rlang::is_empty(elements)) {
    return()
  }

  is_comment <- sapply(elements, function(x) startsWith(as.character(x), "#"))

  # if (!all(is_comment)) write_out(tabs,"fluidRow(\n")

  for (j in seq_along(elements)) {
    msg <- elements[[j]]
    if (startsWith(msg, "#")) {
      write_out(tabs,"  {msg}\n")
    } else {
      write_out(indented(msg))
      # write_out(tabs,'  column(\n',
      #           tabs,'    width=NCOL,\n',
      #           indented(msg),'\n',
      #            tabs,'  )')
      if (any(!is_comment[-(1:j)])) {
        write_out(",\n")
      } else {
        write_out("\n")
      }
    }
  }

  if (!all(is_comment)) write_out(tabs,"),\n")
}

#' Make sure each input is assigned to a group, and they are sorted
assign_groups <- function(config_table) {
  for (line_counter in seq_len(nrow(config_table))) {
    line <- as.list(config_table[line_counter, ])

    if (is_group_header(line)) {
      default_group <- line$group
      next
    }

    if (is.empty(line$group)) {
      if (is.empty(default_group)) {
        stop("Input not assigned to group: ", line$id)
      } else {
        config_table[line_counter, "group"] <- default_group
      }
    } else {
      if (line$group == default_group) {
        next
      }
      stop("Input out of place?: ", line$id)
    }
  }

  config_table$group <- forcats::fct_inorder(config_table$group)
  return(config_table)
}

#' Parse a line of `input_config_table` representing a UI input.
#'
#' @param line a single line (named list) of `input_config_table`
#' @return `list[out, line]` where `out` is a string of code to generate the UI input,
#'  and `line` is potentially modified (strings converted to numbers & rounded)
#'
parse_line <- function(line) {
  line <- as.list(line)
  if (is_group_header(line)) {
    return(list(NULL, line))
  }

  out <- NULL
  super_glue <- function(...) c(out, glue(..., .trim = F, .envir = parent.frame(n = 1)))

  if (!is.empty(line$notes)) {
    out <- super_glue("# {line$notes}")
  }

  # A "complete" entry has ID, description and default value
  # Incomplete entries are just printed as comments.
  line$valid <- !any(is.empty(line[c("id", "description", "default")]))

  if (!line$valid) {
    msg <- stringr::str_flatten_comma(line[!is.empty(line)])
    out <- super_glue("# INVALID: {msg}")
    return(list(out, line))
  }

  if (line$valid && is.empty(line$type)) {
    line$type <- ifelse(is.numeric.ish(line$default), "num", "char")
  }

  # Fake-complete, in case non-matching type
  for (fld in c("id", "description", "default")) {
    if (is.empty(line[fld])) {
      line[fld] <- ""
    }
  }

  if (line$valid && is.numeric.ish(line$default)) {
    line$default <- signif(as.numeric(line$default), digits = 4)
  }

  line$type <- stringr::str_to_lower(glue::trim(line$type))

  # Escape unicode characters
  line$description <- stringi::stri_escape_unicode(line$description)

  if (grepl("num|slider", line$type, ignore.case = T)) {
    list[args, line] <- parse_numeric(line)

    if (grepl("num", line$type, ignore.case = T)) {
      out <- super_glue("numericInput({args})")
      line$type <- "numeric"
    } else {
      out <- super_glue("sliderInput({args})")
      line$type <- "slider"
    }
  } else if (grepl("check|bool|logic", line$type, ignore.case = T)) {
    out <- super_glue('checkboxInput("{line$id}","{line$description}", value = {line$default})')
    line$type <- "checkbox"
  } else if (grepl("table|matrix", line$type, ignore.case = T)) {
    out <- super_glue(
      'shinyMatrix::matrixInput("{line$id}", value = data.matrix({line$default},rownames.force=F),\n',
      '                         rows = list(names = F, editableNames = F),\n',
      '                         cols = list(names = T, editableNames = F),\n',
      '                         class = "numeric")'
    )

    # GOTCHA: matrix must be wrapped in list(), otherwise exit assignment
    # DF[j,] <- line fails, that means that is.matrix(line$default) == F.
    # The matrix must be extracted again with line$default[[1]]
    val <- as.matrix(eval(parse(text=line$default)),rownames.force=F)
    line$default <- list(val)

    line$type <- "matrix"

  } else if (grepl("char|text|txt", line$type, ignore.case = T)) {
    out <- super_glue('textInput("{line$id}","{line$description}")')
    line$type <- "text"

    # } else if  ( grepl("select",line$type,ignore.case=T) ) {
    #
    #   out <- super_glue('selectInput({value = {line$default}})')
  } else if (grepl("file", line$type, ignore.case = T)) {
    # PROVISIONAL: just add file name
    out <- super_glue('textInput("{line$id}","{line$description}")')
  } else {
    msg <- stringr::str_flatten_comma(line[!is.empty(line)])
    out <- super_glue("# UNKNOWN: {msg}")
    line$valid <- FALSE
  }

  return(list(out, line))
}

#' Parse default value, step, and limits (numeric and slider inputs)
#'
#' @param line a single line (named list) of `input_config_table`
#'
#' @return `list[args,line]` Where `args` is a string `'"id","description", min=X, max=...'`
#'  of arguments for `numericInput` or `sliderInput`, and `line` is potentially modified
#'  (strings converted to numbers & rounded)
#'
parse_numeric <- function(line) {
  if (all(is.empty(line)) || !grepl("num|slider", line$type, ignore.case = T)) {
    return(list(args = NULL, line))
  }

  is.slider <- grepl("slider", line$type, ignore.case = T)

  args <- c('"{line$id}"', '"{line$description}"')

  if (!is.empty(line$step)) {
    line$step <- as.numeric(line$step)
    stopifnot(!is.empty(line$step) && line$step > 0)

    args <- c(args, "step = {line$step}")
  } else {
    line$step <- as.numeric(NA)
  }

  if (!is.empty(line$default)) {
    line$default <- custom_round(line$default, line$step)
    args <- c(args, "value = {line$default}")
  }

  parse_lim <- function(minmax) {
    if (minmax == "min") {
      round_op <- ceiling
    } else if (minmax == "max") {
      round_op <- floor
    } else {
      stop('Expecting "min" | "max"')
    }

    rel_lim <- line[[paste0("rel_", minmax)]]
    abs_lim <- line[[paste0("abs_", minmax)]]

    if (!is.empty(rel_lim) && !is.numeric.ish(rel_lim)) {
      # TODO: dynamic constraints
      # updateSliderInput(inputId = "n", min = input$min)

      rel_lim <- NA
      warning("Unhandled relative min for input: ", line$id)
    }

    rel_lim <- as.numeric(ifelse(is.numeric.ish(rel_lim), rel_lim, NA))
    abs_lim <- as.numeric(ifelse(is.numeric.ish(abs_lim), abs_lim, NA))

    rel_lim <- custom_round(rel_lim, line$step, round_op)
    abs_lim <- custom_round(abs_lim, line$step, round_op)

    if (!is.na(abs_lim) && !is.na(rel_lim)) {
      rel_lim <- min(abs_lim, rel_lim)
    }

    arg <- c()
    if (!is.na(rel_lim)) {
      arg <- glue(minmax, " = {rel_lim}")
    } else if (!is.na(abs_lim)) {
      arg <- glue(minmax, " = {abs_lim}")
    } else if (is.slider) {
      warning("Missing min for sliderInput: ", line$id)
    }

    line[[paste0("rel_", minmax)]] <<- rel_lim
    line[[paste0("abs_", minmax)]] <<- abs_lim
    return(arg)
  }

  args <- c(args, parse_lim("min"))
  args <- c(args, parse_lim("max"))
  args <- glue(stringr::str_flatten_comma(args))

  return(list(args, line))
}


# main ------------------------------------------------------------------------------------------------------------

devtools::load_all()

# source("dev/add_use_data.R")

INPUT_FILE <- "data-raw/input_config.tsv"
OUTPUT_UI <- "R/auto_generated_ui.R"

parse_ui_table()
