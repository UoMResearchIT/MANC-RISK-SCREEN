#' Development tool, used to generate a simple UI from the configuration table
#' of model inputs "dev/input_config.csv"
#'
#' Writes a function "R/auto_generated_ui.R" returning a fluidPage object,
#' to be used in "app_ui.R". The format and parsing is controlled by
#' `write_chunk` below.
#'
#' It also exports the parsed table `data/input_config_table.rda`, which is
#' used by functions in `R/utils.R` to identify model input types and
#' configurations.

devtools::load_all()

# library("glue")
# library("stringr")
# library("gsubfn")

# source("dev/add_use_data.R")

INPUT_FILE <- "data-raw/input_config.csv"
OUTPUT_UI <- "R/auto_generated_ui.R"

parse_ui_table <- function() {

  # Expected column names
  COL_NAMES <- c("group", "id", "type", "basic", "fixed", "default", "rel_min", "rel_max", "abs_min", "abs_max", "step", "symbol", "unit", "description", "notes")

  # Read input config table from INPUT_FILE, make sure all columns are available
  input_config_table <- read.delim(INPUT_FILE, na.strings = c("NA", "?", ""), blank.lines.skip = T)

  input_config_table$default <- I(as.list(input_config_table$default))

  stopifnot(rlang::is_empty(setdiff(COL_NAMES, colnames(input_config_table))))

  # Remove empty lines
  empty_lines <- apply(input_config_table, 1, is.empty)
  input_config_table <- input_config_table[!empty_lines, ]

  # Make sure each input is assigned to a group, and they are sorted
  input_config_table <- assign_groups(input_config_table)

  # config_table$basic

  # Keep a list of all inputs...
  # add_to_list(config_table$id,"all_inputs")

  input_config_table$valid <- !sapply(input_config_table$id, is.empty)
  input_config_table$basic <- grepl("[xty1]+", input_config_table$basic, ignore.case = T)
  input_config_table$fixed <- grepl("[xty1]+", input_config_table$fixed, ignore.case = T)

  # main --------------------------------------------------------------------

  write_out("# Code generated by parse_ui_table.R, ", date(), "\n", append = F)
  write_out("# Edit input config in: data_raw/input_config.csv:\n")
  write_out("# Edit parsing rules & layout in: data_raw/parse_ui_table.R\n")

  write_out("auto_generated_ui <- function() {{\n\n")

  write_out("NCOL <- 3\n\n")

  write_out(
    "fluidPage(\n",
    "  # Customize this header later\n",
    "  shinyjs::useShinyjs(),\n",
    "  shinyFeedback::useShinyFeedback(),\n",
    '  h1( paste("MancRiskScreenUI -", packageVersion("MancRiskScreenUI")) ),\n',
    '  textOutput("intro_text"),\n\n\n'
  )

  for (grp in levels(input_config_table$group)) {
    in_grp <- input_config_table$group == grp
    chunk <- input_config_table[in_grp, ]

    chunk <- parse_chunk(chunk)

    input_config_table[in_grp, ] <- chunk
  }

  write_out(
    "\n\n",
    "  # Customize this closure later\n",
    '  h3("Model outputs"),\n',
    '  plotOutput("qualy_plot"),\n',
    '  plotOutput("cost_plot"),\n',
    '  h3("Status"),\n',
    '  verbatimTextOutput("status"),\n\n',
    ")\n"
  )

  write_out("\n\n}}")

  ok <- input_config_table$valid
  dup <- ok
  dup[ok] <- duplicated(input_config_table$id[ok])
  ok <- ok & !dup

  rownames(input_config_table)[ok] <- input_config_table$id[ok]

  if (any(dup)) {
    msg <- input_config_table[dup, c("group", "id", "type", "description")]
    msg <- paste(capture.output(print(msg)), collapse = "\n")
    stop("Non-unique input IDs!\n", msg)
  }

  # add_use_data("input_config_table" = input_config_table)
  usethis::use_data(input_config_table, internal = F, overwrite = T)
}

is.empty <- function(x) {
  (all(rlang::is_empty(x) | is.na(x) | x == ""))
}

write_out <- function(..., file = OUTPUT_UI, append = T) {
  cat(glue(..., .trim = F, .envir = parent.frame(n = 1)), file = file, append = append)
}

is.numeric.ish <- function(x) !is.empty(x) && !suppressWarnings(is.na(as.numeric(x)))

is_group_header <- function(line) !is.empty(line$group) && is.empty(line$id)

parse_chunk <- function(chunk) {
  stopifnot(length(unique(chunk$group)) == 1)
  group <- as.character(chunk$group[1])

  elements <- NULL
  for (j in seq_len(nrow(chunk))) {
    line <- as.list(chunk[j, ])
    list[x, line] <- parse_line(line)

    elements <- c(elements, x)
    chunk[j, ] <- line
  }

  write_chunk(group, elements)
  return(chunk)
}


# Writes h2 headers for every non-empty cell in the "Group" column (A:A),
# then wraps every line until the next header into a FluidRow column.
#
#  h2("Header"),
#  fluidRow(
#    column(width=NCOL, numericInput("foo", "Foo?", value = 42) ),
#    # Commented incomplete rows
#    column(width=NCOL, sliderInput("bar", "Bar?", value = 0.5, min = 0, max = 1) )
#  ),
#
write_chunk <- function(group, elements) {
  write_out('  h2("{group}"),\n')

  if (rlang::is_empty(elements)) {
    return()
  }

  is_comment <- sapply(elements, function(x) startsWith(as.character(x), "#"))

  if (!all(is_comment)) write_out("  fluidRow(\n")

  for (j in seq_along(elements)) {
    msg <- elements[[j]]
    if (startsWith(msg, "#")) {
      write_out("   {msg}\n")
    } else {
      write_out("    column(width=NCOL, {msg} )")
      if (any(!is_comment[-(1:j)])) {
        write_out(",\n")
      } else {
        write_out("\n")
      }
    }
  }

  if (!all(is_comment)) write_out("  ),\n")
}

assign_groups <- function(config_table) {
  for (line_counter in seq_len(nrow(config_table))) {
    line <- as.list(config_table[line_counter, ])

    if (is_group_header(line)) {
      default_group <- line$group
      next
    }

    if (is.empty(line$group)) {
      if (is.empty(default_group)) {
        stop("Input not assigned to group: ", line$id)
      } else {
        config_table[line_counter, "group"] <- default_group
      }
    } else {
      if (line$group == default_group) {
        next
      }
      stop("Input out of place?: ", line$id)
    }
  }

  config_table$group <- forcats::fct_inorder(config_table$group)
  return(config_table)
}

parse_line <- function(line) {
  line <- as.list(line)
  if (is_group_header(line)) {
    return(list(NULL, line))
  }

  out <- NULL
  super_glue <- function(...) c(out, glue(..., .trim = F, .envir = parent.frame(n = 1)))

  if (!is.empty(line$notes)) {
    out <- super_glue("# {line$notes}")
  }

  # A "complete" entry has ID, description and default value
  # Incomplete entries are just printed as comments.
  line$valid <- !any(is.empty(line[c("id", "description", "default")]))

  if (!line$valid) {
    msg <- stringr::str_flatten_comma(line[!is.empty(line)])
    out <- super_glue("# INVALID: {msg}")
    return(list(out, line))
  }

  if (line$valid && is.empty(line$type)) {
    line$type <- ifelse(is.numeric.ish(line$default), "num", "char")
  }

  # Fake-complete, in case non-matching type
  for (fld in c("id", "description", "default")) {
    if (is.empty(line[fld])) {
      line[fld] <- ""
    }
  }

  if (line$valid && is.numeric.ish(line$default)) {
    line$default <- signif(as.numeric(line$default), digits = 4)
  }

  line$type <- stringr::str_to_lower(glue::trim(line$type))

  # Escape unicode characters
  line$description <- stringi::stri_escape_unicode(line$description)
  if ( !is.empty(line$symbol) ) {
    line$symbol <- stringi::stri_escape_unicode(line$symbol)
  }
  if ( !is.empty(line$unit) ) {
    line$unit <- stringi::stri_escape_unicode(line$unit)
  }

  if (grepl("num|slider", line$type, ignore.case = T)) {
    list[args, line] <- parse_numeric(line)

    if (grepl("num", line$type, ignore.case = T)) {
      out <- super_glue("numericInput({args})")
      line$type <- "numeric"
    } else {
      out <- super_glue("sliderInput({args})")
      line$type <- "slider"
    }
  } else if (grepl("check|bool|logic", line$type, ignore.case = T)) {
    out <- super_glue('checkboxInput("{line$id}","{line$description}", value = {line$default})')
    line$type <- "checkbox"
  } else if (grepl("table|matrix", line$type, ignore.case = T)) {
    out <- super_glue(
      'shinyMatrix::matrixInput("{line$id}", value = data.matrix({line$default},rownames.force=F),\n',
      "rows = list(names = F, editableNames = F),\n",
      "cols = list(names = T, editableNames = F),\n",
      'class = "numeric")'
    )

    # GOTCHA: matrix must be wrapped in list(), otherwise exit assignment
    # DF[j,] <- line fails, that means that is.matrix(line$default) == F.
    # The matrix must be extracted again with line$default[[1]]
    val <- as.matrix(eval(parse(text=line$default)),rownames.force=F)
    line$default <- list(val)

    line$type <- "matrix"

  } else if (grepl("char|text|txt", line$type, ignore.case = T)) {
    out <- super_glue('textInput("{line$id}","{line$description}")')
    line$type <- "text"

    # } else if  ( grepl("select",line$type,ignore.case=T) ) {
    #
    #   out <- super_glue('selectInput({value = {line$default}})')
  } else if (grepl("file", line$type, ignore.case = T)) {
    # PROVISIONAL: just add file name
    out <- super_glue('textInput("{line$id}","{line$description}")')
  } else {
    msg <- stringr::str_flatten_comma(line[!is.empty(line)])
    out <- super_glue("# UNKNOWN: {msg}")
    line$valid <- FALSE
  }

  return(list(out, line))
}

# Parse default value, step, and limits (numeric and slider inputs)
#
#   list[args,line] <- parse_numeric(line)
#
# Where args = '"id","description", min=X, max=...'
# and line is potentially modified (strings converted to numbers & rounded)
parse_numeric <- function(line) {
  if (all(is.empty(line)) || !grepl("num|slider", line$type, ignore.case = T)) {
    return(list(args = NULL, line))
  }

  is.slider <- grepl("slider", line$type, ignore.case = T)

  args <- c('"{line$id}"', '"{line$description}"')

  if (!is.empty(line$step)) {
    line$step <- as.numeric(line$step)
    stopifnot(!is.empty(line$step) && line$step > 0)

    args <- c(args, "step = {line$step}")
  } else {
    line$step <- as.numeric(NA)
  }

  if (!is.empty(line$default)) {
    line$default <- custom_round(line$default, line$step)
    args <- c(args, "value = {line$default}")
  }

  parse_lim <- function(minmax) {
    if (minmax == "min") {
      round_op <- ceiling
    } else if (minmax == "max") {
      round_op <- floor
    } else {
      stop('Expecting "min" | "max"')
    }

    rel_lim <- line[[paste0("rel_", minmax)]]
    abs_lim <- line[[paste0("abs_", minmax)]]

    if (!is.empty(rel_lim) && !is.numeric.ish(rel_lim)) {
      # TODO: dynamic constraints
      # updateSliderInput(inputId = "n", min = input$min)

      rel_lim <- NA
      warning("Unhandled relative min for input: ", line$id)
    }

    rel_lim <- as.numeric(ifelse(is.numeric.ish(rel_lim), rel_lim, NA))
    abs_lim <- as.numeric(ifelse(is.numeric.ish(abs_lim), abs_lim, NA))

    rel_lim <- custom_round(rel_lim, line$step, round_op)
    abs_lim <- custom_round(abs_lim, line$step, round_op)

    if (!is.na(abs_lim) && !is.na(rel_lim)) {
      rel_lim <- min(abs_lim, rel_lim)
    }

    arg <- c()
    if (!is.na(rel_lim)) {
      arg <- glue(minmax, " = {rel_lim}")
    } else if (!is.na(abs_lim)) {
      arg <- glue(minmax, " = {abs_lim}")
    } else if (is.slider) {
      warning("Missing min for sliderInput: ", line$id)
    }

    line[[paste0("rel_", minmax)]] <<- rel_lim
    line[[paste0("abs_", minmax)]] <<- abs_lim
    return(arg)
  }

  args <- c(args, parse_lim("min"))
  args <- c(args, parse_lim("max"))
  args <- glue(stringr::str_flatten_comma(args))

  return(list(args, line))
}

parse_ui_table()
